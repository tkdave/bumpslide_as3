/**
 * This code is part of the Bumpslide Library maintained by David Knape
 * Fork me at http://github.com/tkdave/bumpslide_as3
 * 
 * Copyright (c) 2010 by Bumpslide, Inc. 
 * http://www.bumpslide.com/
 *
 * This code is released under the open-source MIT license.
 * See LICENSE.txt for full license terms.
 * More info at http://www.opensource.org/licenses/mit-license.php
 */

package com.bumpslide.data {	import com.bumpslide.events.ModelChangeEvent;
	import com.bumpslide.util.Delegate;
	import com.bumpslide.util.ObjectUtil;
	import com.bumpslide.util.StringUtil;
	
	import flash.events.EventDispatcher;
	import flash.utils.Timer;		

	/**	 * Bindable model implentation	 * 	 * This is an abstract class meant to be used as a base 	 * class for data classes such as those that track 	 * application state.	 * 	 * By extending this class and implementing your model using getters and 	 * setters that call the 'get' and 'set' functions, you can listen for changes 	 * using either event dispatcher or the Binding class. 	 * 	 * @author David Knape	 */	public class BindableModel extends EventDispatcher implements IBindable {		//        // Bindable property 'sample'		//        public function get sample () : String { return get('sample'); }		//        public function set sample ( s:String ) : void { set('sample', s); }				public var debugEnabled:Boolean = false;		protected var notificationDelay:int = 10;		protected var pendingNotification:Timer;		protected var currentValues:Object;		protected var pendingValues:Object;		protected var changedProperties:Array;				/**		 * Creates new model, inits internal storage		 */		public function BindableModel() {			currentValues = new Object();					pendingValues = new Object();			changedProperties = new Array();				}				public function bind( property:String, target:Object, setterOrFunction:*=null ) : Binding {			return Binding.create( this, property, target, setterOrFunction );		}				public function unbind( target:Object, property:String=null ) : void {			Binding.remove(target, property);		}				/**		 * Get property by name		 */		protected function get(property:String):* {			if(pendingValues[property] !== undefined) return pendingValues[property];			return currentValues[property];		}		/**		 * set property by name		 */		protected function set(property:String, newValue:* ):void {			//debug('attempt to set '+property+' to ' + newValue + ' (currentValue=='+currentValues[property] +')');						// if value is equal to the current value			if (!equal(currentValues[property] , newValue)) {				pendingValues[property] = newValue;				invalidate(property);			} else {				validate(property);			} 		}			/**		 * Uses byteArray comparison to determine if two values are equal		 */		protected function equal( val1:*, val2:* ):Boolean {			//return val1==val2;			return ObjectUtil.equals(val1, val2);		}			/**		 * Triggers a notification that a property has changed		 * 		 * Notification happens after a brief delay, so that multiple 		 * changes can be gathered together and broadcast as a group.		 */		protected function invalidate(property:String):void {			if(changedProperties.indexOf(property) != -1) return;			changedProperties.push(property);				Delegate.cancel( pendingNotification );			pendingNotification = Delegate.callLater(notificationDelay, notifyChanged);		}		/**		 * Removes property from changedProperties list and cancels pending notification 		 */		protected function validate(property:String):void {						// remove prop from changedProperties list			var i:int = changedProperties.indexOf(property);			if(i!=-1) {				changedProperties.splice(i, 1);			}			pendingValues[property] = undefined;			// cancel pending notification if necessary			if(changedProperties.length==0) {				Delegate.cancel( pendingNotification );			}		}		/**		 * Loops through list of changedProperties and dispatches a ModelChangeEvent for each one		 * 		 * Here is also where we update the currentValues array and reset the 		 * changedProperties list and pendingValues Object		 */		protected function notifyChanged():void {					//log('notifyChanged()');			for each ( var property:String in changedProperties ) {							var newValue:* = pendingValues[property];				var oldValue:* = currentValues[property];								var logVal:String = newValue!=null ?  StringUtil.abbreviate( String(newValue) ) :  'null';				if(newValue is Array) {					logVal = "Array("+(newValue as Array).length+") : " + logVal; 				}				debug( 'changed "'+ property + '" to ' + logVal );	        	currentValues[property] = pendingValues[property];	        					dispatchEvent(new ModelChangeEvent(this, property, newValue, oldValue));			}			changedProperties = new Array();			pendingValues = new Object();		}		/**		 * trace		 */		protected function debug( msg:String ):void {			if(!debugEnabled) return;			trace(this + ' ' + msg);		}		override public function toString():String {			return "[Model]";		}	}}